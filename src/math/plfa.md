---
vim: nofoldenable
title: plfa笔记
description: 大概是读plfa时候qwq到的一点东西
...

# 杂项

就是一些可能用到但也不知道放哪的东西, 索性都丢这算了. (超小声(

## 启用Agda的输入法

senioria是用的fcitx5做全局的输入法, 然后在各个编辑器里都稍微配置了下.
但要输入Agda里的众多Unicode字符的话, 那自然还是直接用agda-mode自带的输入法香.

当然, 这两个并不冲突, 在Emacs中配置fcitx5属于其它话题, 在非Agda的文件里启用Agda的输入法的话:

``` { .text .number-lines }
M-: (require 'agda-input)
(insert mode) C-\ Agda
```

(senioria某种程度上把Emacs当Vim在用: 要用的时候拉起一个进程, 写完了就关掉... (超小声(

# `double-subst` at Part2.More

题面:

``` agda
double-subst : ∀ {Γ A B C} {V : Γ ⊢ A} {W : Γ ⊢ B} (N : Γ , A , B ⊢ C)
               → N [ V ][ W ] ≡ (N [ rename S_ W ]) [ V ]
```

(TODO: 据cld说, 这是个错题 x (超小声(

但其实我们很明显地可以看到, 这个命题本身是对的:
等号左边是一次替换掉context最上层的两个变量, 右边是依次替换掉两个变量.
那么因为这两个表达式做的都只是替换这两个变量, 为了证明它们相等, 我们只需要证明它们替换掉的变量一样即可.
同时, 根据替换的性质, 我们可以知道, 唯一可能产生区别的地方是, 左边替换的`W`中的内容不会被`V`替换, 而右边可能.
又, 注意到左边的`rename S_ W`提升了`W`中每一个变量在context中的深度, 而替换`V`的时候只替换栈顶的变量,
所以, `V`不会替换`W`替换产生的变量, 等式成立.

那么, 等有能力了再来形式化地证 x (超小声(被打死((((((

# `products` at Part2.Bisimulation

题面: 证明两个解构操作`proj₁`和`proj₂`的集合和一个解构操作`case×`之间存在双模拟.

我们可以选择用`case×`来模拟`proj₁`和`proj₂`, debruijn表示下的模拟如下:

``` agda
-- 我们知道, `case×`的签名是`Γ ⊢ A `× B → Γ , A , B ⊢ C → Γ ⊢ C`
proj₁ M = case× (M †) (` (S Z))
proj₂ M = case× (M †) (` Z)
```

它们之间的每个化约的模拟关系大概都比较显然, 不论是正向还是反向.
同时, 注意到, 这些模拟的化约并非正文里那样在通过变换已有的化约得到新的化约,
更多的是在已有化约的结果之后加上一步新的化约;
所以, 这里的化约不是一对一的, 在两边的模拟中, 每一步的化约都会对应另一边的多步化约.

具体的证明思路的话, 简单地抄一下上面的思路, 再枚举一下构造, 利用归纳法就可以了.

## 不可行的另一种模拟思路

plfa里首先给出的是另一种模拟方法:

``` agda
case× L [⟨ x , y ⟩⇒ M ] = let z = L † ; x = proj₁ z ; y = proj₂ z in M †
	                    = (λ z ⇒ (λ x y ⇒ M †) · proj₁ z · proj₂ z) · L †
```

然而这种模拟方式无法构成双模拟, 甚至连正向模拟也有问题:
plfa里的语言无法引入`z`这个新变量, 所以正向模拟的时候无法写出对应的表达式;
另外, 反过来的时候, lambda表达式里的每次应用并不能对应到`case×`这个表达式里的一个化约序列 ---
下面的lambda表达式的确就比上面的`case×`粒度更小.

