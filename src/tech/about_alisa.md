---
title: About Alisa language
author: [Alissa, Senioria]
description: 对某个饼(bushi)的介绍
...

[^0]Alisa... 是个... Senioria从很早之前[^1]就给自己画下来了的饼(((
但是一直没有能力实现她: 在Senioria有能力实现之前的构想的时候,
新的Senioria没法实现的想法又出来了(((
直到这次... Senioria想做一个好点的类型系统...
然后就发现自己只能咕到大学了(趴[^2]
总之要读书就对了qwq(趴

所以... 在blog里摸篇文章来记录一下到现在为止Senioria的构想.
因为不是spec所以大概有点随便x
而且... 所有例子都不是最终语法, 只是目前的想法...

[^1]: 大概... 是初中的时候(((
[^0]: ~~这似乎是这个blog的第一篇技术文~~
[^2]: 并且... 发现似乎不比Racket好... qwq

# 目标和哲学

主要的目标大概是这些:

- 高效: 和C/C++/Rust一样~~(如果别的语言也在吹效率的话...\ 那就和它们也一样x~~
- 简单: 语法/语义的一致性好, 基本语法(指为了能够糊出东西来需要学的语法)少,
  没了解过的东西除非自己瞎玩, 不然不可能出现在视野中
- 灵活: 语言里固定的东西少, 并且自定义能力强
  (当然类型系统, 名字查找规则这种东西大概是不能不放私货的qwq(((
- 完备: ~~当然图灵完备是必须的~~ 类型系统sound(虽然不知道按照现在画出来的饼能不能做到

哲学的话, 大概和C++差不多~~(惨了估计要被讨厌了)~~: 尽量不强加设计者的哲学给用户,
给用户最大的自由, 但是也允许用户基于自己的哲学来限制自己的自由.

# 基本语法

和scheme~~其实只有Racket~~很相似(因为有很多照抄的部分())

大概变的地方有:

- `quote`的糖从`'`换成了`#'`, 为了基本语法的简单稍微麻烦了点(((
  ~~(而且也没有哪个语言是允许`'`作变量名的(((~~

- 加了`#::`用来访问不同作用域的变量(大概是路径的概念).
  (当然作用域之间还是会相互shadow的)
  一个例子(虽然大概不会设计成这个样子)是:

  ```scheme
  (let ([read 0])
    (open fname #::open::read #:read-to read))
  ```

- 用`#>`来标识一个表达式需要具有的约束(类型).

- 用`#@`来引入装饰器(大概... 用来引入一些宏/在函数里实现一些特殊功能?(
  比如:

  ```scheme
  (bind-type (print format #>String
      #@optional file #>File end #>String
      #@rest args #>(Const compile-time (array (Const (ref Any))))) #>IO-Result)
  ```

- 注释方面的一些魔改(因为加了很多`;`开头的特殊注释所以其实建议用<code>;&nbsp;</code>或者`;;`来开始行注释),
  允许注释之间嵌套:

  - 块注释是`;(`和`;)`(似乎和大多scheme方言都不一样(
  - 文档注释(用来(用某些子语言?)生成文档之类的?())是`;@{`和`;}`

- 允许在第一行用`#!`来定义shebang(反正`#`开头的也是特殊语法((()

继承的语法的话:

- 允许`([])`两种括号共存(虽然似乎是Racket私货(((
- `#:`来指定命名参数
- `#\`形式的字符常量(不过想允许C++风格的转义存在)
- `""`形式的字符串常量(同样, 想允许C++风格的转义(((

Senioria不想搞出一堆名字污染用户的全局命名空间, 所以默认只会导入很小一部分名字, 而且全部是`#`开头的
(除了这些函数之外, 别的名称都不能以`#`开头.

- `#import`, 正如它的名字所示, 用来导入一个模块;
- `#import-submodule`, 用来导入另一个模块, 作为当前模块的子模块.
  虽然这种东西似乎不是很适合放在语核里(那么多更该放的都还没放呢()),
  但是既然当前的模块系统需要在代码里处理的东西就这么多了, 放进去似乎也无所谓,
  反正产生的历史遗留也好翻译x;
- `#named-pair`, 用来实现命名参数(虽然任何用来定义函数的方法都要导入另外的模块);
- `#constraint`, 用来实现类型约束(虽然这似乎不该暴露个函数来(((;
- `#decorator`, 用来实现装饰器;
- `#resolve-path`, 用来解析路径, 找到它指涉的东西的;
- `#private`, 用来作为私有模块的路径的根的别名(虽然... 是由`#import`引入的).

因此, 用户创建的名字的硬限制只有两条:
不能包含`#[]();"`这些字符中的任何一个或者任何空白字符, 并且不能以数字开头.
虽然, 建议的命名风格还是scheme的: 用朴素的英文单词命名, 中间用`-`分隔.
并且, 因为`::`是路径的一部分, 不建议将其用在名字中(虽然其实路径本身也只是一个标识符).

# 作用域

作用域方面... 除了一般的作用域之外,
每个函数/函数的参数还可以创建一个仅在它被调用时的参数列表内有效的作用域,
用来临时提供一些常量... 例子(还是上面那个):

```scheme
(let ([read 0])
  (open fname #::open::read #:read-to read)
  (open fname #::open-type::write #:write-from read))
```

其中`#::open::read`就是`open`提供的打开文件的选项之一.
这个例子也展示了:

- 外层名字在名字查找中总是优先于函数/参数引入的名字的;
- 函数引入的名字, 路径的根是函数名, 参数引入的名字, 路径的根是参数名;
  没有显示的是, 如果还有歧义的话, 也可以用`#::open::open-type::write`这种方式来引用.

## 基于路径的名字查找

~~虽然只是(比较细枝末节的)补丁~~

因为... 函数引入的常量和局部变量可能会(不可避免地)重名(不同的两个函数引入的名称也有可能重名)...
所以... 加个路径的糖来区分这两种作用域里的名称似乎是有必要的.
语法的话, 上面似乎已经写过很多次了x

另外, 因为有可能要加struct之类的东西, 路径似乎也是个很好的访问对象的域的办法
~~虽然比`.`这个语法啰嗦多了但是反正可以用reader\ macro加糖嘛,\ 而且总比用函数访问一点糖不加好(((~~

具体一点的介绍的话, 有几个特例:

- `#import`里的路径不需要`#::`限定(因为默认就是路径)(虽然也可以加就是了)

- 如果路径内的名字包含`::`, 就只能显式用`#resolve-path`并挨个指定每个路径成分, 比如:

  ```scheme
  (define (path-with-:: arg #>(enum A)))
  (path-with-:: (#resolve-path path-with-:: A))
  ```

# 类型系统

(Senioria大概是从工程而非学术角度来阐述的><

(虽然类型推导并不属于类型系统的一部分)
一般来说所有量的类型都是编译器自动推导的,
只有在想加更多限制/编译器推导不出来的时候才需要手动介入.

类型系统本身的话... 因为类型大概只是约束,
所以理论上不能直接用某种约束(概念)的实现本身(但是实际上总是可以弄出same-as这种约束的()).
同时... 这种约束应该尽量做到0运行时代价.

约束本身当然是布尔函数: 传入另一个约束/约束的实例化, 返回后者是否满足自己的要求.
不过... 打算在使用约束的时候能够拥有传入一些参数以控制约束的能力, 比如:

```scheme
;; 限定范围
(define ranged-int #>(Int #:range #'(1 100)) 1)
;; 动态的限定也可以(但会有动态的检查代价)
(define dynamic-ranged-int #>(Int #:range #'(0 ranged-int)) 2)
```

(感觉一句话就可以概括个差不多了: Racket的类型系统和宏系统, 加上编译时运行函数的支持

另外的话, 还有effect system, 跟类型系统大概是同一个架构, 并且是正交的...
用来限制一个函数内, 在不使用另一个函数的结果的情况下(这个时候大概就没办法用类型系统来限制了),
能否使用这个函数.

# 模块系统

模块被`#import`的路径是由它的源代码文件在文件系统内的路径决定的,
可以用相对路径来查找模块, 并且默认的路径就是相对路径
(i.e. 无法查找位于父目录内的模块), 比如`io::out`.
当一个路径可以同时解析到相对路径内的模块和模块引入路径内的模块时, 优先引入相对路径内的,
此时模块引入路径内的模块的路径大概类似`::io::out`.

因为名字不能以`#`开头, 所以所有以`#`开头的目录都是同名(去掉`#`之后的名字)模块的私有实现,
可以且只可以被该模块引用(语法大概是`#private::out`,
或者`#::#io::out`(因为不允许用户名称以`#`开头所以只好显式用完整路径)以和默认的路径语法一致[^private_disambi]).
这个目录内的模块并不知道它们处于一个模块的私有实现内.

[^private_disambi]: 这个规则可能有歧义的唯一情况是路径以`#::#private`开头的时候,
  也即, 访问一个叫`private`的模块的私有部分, 但这个时候两种解释的效果一样

`#import-submodule`可以用来把其它模块内的东西也作为当前模块的一部分(这个名字似乎有点不好).
这样也可以把一个模块的实现拆分到不同的文件里.

应该需要一点`std::io::{in, out}`这样的糖的样子((( 不过应该属于标准库内容(

