---
vim: nofoldenable
title: Senioria的代码规范
description: (其实是给自己看的x
author: Senioria
...

~~(其实很多比较早的代码都没有遵循这些~~

# Git

如果所在项目里有规范的话, 尽量遵循项目的规范.

commits尽量提交小的更改.

当原型设计完成后, 使用不同的分支来添加新功能和fix bugs.

commit message使用`动词 模块: 消息`的格式, 尽量写得简短,
因为过长的提交信息往往意味着这一个提交里的内容过多, 不是什么好的迹象.
不过一个例外是解释自己的算法设计, 这么做的目的之类的, 这个时候就另起一段说明.

如果是某个模块的子模块之类的, 用`/`来分隔模块路径中的不同部分.
如果涉及不止一个模块, 比较短的时候用`&`来连接不同模块, 长的时候考虑拆commit, 或者不写模块部分.

不同的动词大概如下:

- feat: 添加了新功能;
- fix: 修复了bug;
- infra: 改进了开发的体验;
- doc: 文档相关的东西;
- refa: 重构了什么东西;
- misc: 某几项的混合, 应该避免这个.

# Markdown

如果可能的话, 尽量使用软换行, 并且尽量在意群的交界处换行.

# C/C++

如果有代码格式化工具的话, 永远遵循这些自动化工具的指示, 除非它们给出的结果实在太不可接受了.
(比如clang-format 12之类的版本完全不认识C++ concepts, 这时候就认为这些结果不可接受.)

其它语言的规则大概和这里的也类似.

## 零碎的东西

尽量不写太长的函数/块, 能拆开的东西尽量拆开.

尽量避免作用域污染, 一个名字的作用域应该尽量小.

## 命名规则

- 头文件/目录/模块/命名空间: `snake_case`
- 类/概念: `CamelCase`
- 常量/宏: `ALL_CAPITAL`
- 函数: `snake_case`
- 成员: `snake_case`
- 局部变量/lambda: `nodelim`或者`snake_case`

模块和命名空间之类的东西一般会尽可能用复数, 比如`parsers`;
诸如`alisa_parser`这种特化的东西会用单数.

类的名称一般遵循对象+动词用作职业的名词这个形式, 比如`AlisaParser`;
或者类似`ParserInfo`这样的职业名词(作形容词)+名词的形式.
有些用作命名空间的类(比如`environments`)遵循命名空间的格式.

概念被用于描述一个对象所应该具有的性质, 正如其名称所述
(因此, 用于拓展的接口之类的会被做成类/接口/元类, 要求用户继承),
因此名称是用于描述状态的词, 比如`Sized`, `SizeChangable`.

常量的名称大概是名词.
一个特例是header guard, 会遵循头文件名大写+`_INCLUDED`的名字, 比如`QWQ_HPP_INCLUDED`.

函数大概是Qt规则, 即动词+对象; get/set在不产生歧义的时候可能会被省略.
成员会尽量凑成名词/名词性短语.

局部变量会放飞自我(((

## 空格

控制语句的括号前空一格, `for`语句和各种带init的控制语句的分号后空格.

一般来说, 二元(和三元)运算符的参数和运算符之间空格, 数组下标访问除外, 一元运算符不空格.

括号内不空格.

## 换行

函数名和返回类型写在同一行, 如果有换行必要, 尽量换类型的行.

对表达式换行时, 把运算符换到下一行的行首.

大括号换行, 因为大括号是语句块的开始, 换句话说就是一个单独语句的开始, 应该位于自己单独的一行上.

else之类的语句另起一行, 理由同上.

在不同的函数之间添加空行, 不同的意群之间添加三个空行.

## 注释

header guard的`#endif`后加注释表明guard, 命名空间的回括号后加上`End namespace xxx`,
对于匿名命名空间, 是`End anonymous namespace`.

尽量使用注释为类型和函数添加文档, 在算法的不同步骤里也尽量添加注释.

# Rust/etc.

大括号不换行, 因为Rust的大括号/语句块是一个表达式, 而且在一些语法结构里, 大括号本身也是一个定界符.

else和它对应的if的大括号处于同一行, 理由也类似.

# Python/Lua/VimScript/etc.

表达式换行时, 运算符留在上一行的行末, 因为这些语言是依靠换行符来决定语句的边界的, 这个时候换行可能导致parse出问题.

VimScript如果使用的是旧式的换行, 运算符也换到下一行的行首, 因为有显式的续行标记, 不用担心parse问题.

